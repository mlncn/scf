We should be able to do without a widget_settings at all; Eaton's asin (Amazon submodule) doesn't implement it.

/** * Implementation of hook_widget_settings().
 *
 * From noderefcreate module (not on Drupal's CVS). */function biblioreference_widget_settings($op, $widget) {  switch ($op) {    case 'form':      $form = array();      $match = isset($widget['autocomplete_match']) ? $widget['autocomplete_match'] : 'contains';      if ($widget['type'] == 'biblioreference_autocomplete') {        $form['autocomplete_match'] = array(          '#type' => 'select',          '#title' => t('Autocomplete matching'),          '#default_value' => $match,          '#options' => array(            'starts_with' => t('Starts with'),            'contains' => t('Contains'),          ),          '#description' => t('Select the method used to collect autocomplete suggestions. Note that <em>Contains</em> can cause performance issues on sites with thousands of nodes.'),        );      }      else {        $form['autocomplete_match'] = array('#type' => 'hidden', '#value' => $match);      }      return $form;    case 'save':      return array('autocomplete_match');  }}


Modeled on:
function nodereference_widget_settings($op, $widget) {  switch ($op) {    case 'form':      $form = array();      $match = isset($widget['autocomplete_match']) ? $widget['autocomplete_match'] : 'contains';      if ($widget['type'] == 'nodereference_autocomplete') {        $form['autocomplete_match'] = array(          '#type' => 'select',          '#title' => t('Autocomplete matching'),          '#default_value' => $match,          '#options' => array(            'starts_with' => t('Starts with'),            'contains' => t('Contains'),          ),          '#description' => t('Select the method used to collect autocomplete suggestions. Note that <em>Contains</em> can cause performance issues on sites with thousands of nodes.'),        );      }      else {        $form['autocomplete_match'] = array('#type' => 'hidden', '#value' => $match);      }      return $form;    case 'save':      return array('autocomplete_match');  }}




@TODO - follow KarenS' lead on moving code not needed every page load:

/** * Implementation of hook_widget(). * * This code and all the processes it uses are in a separate file, * included only when processing forms. */function date_widget(&$form, &$form_state, &$field, $items, $delta) {  require_once('./'. drupal_get_path('module', 'date') .'/date_elements.inc');  return _date_widget($form, $form_state, $field, $items, $delta);}/** * Implementation of hook_elements(). * * This code and all the processes it uses are in a separate file, * included only when processing forms. */function date_elements() {  require_once('./'. drupal_get_path('module', 'date') .'/date_elements.inc');  return _date_elements();}






CUT:

/** * Implementation of hook_content_is_empty(). */function biblioreference_content_is_empty($item, $field) {  if (empty($item['nid'])) {    return TRUE;  }  return FALSE;}fairly certain this is for fields, not widgets.




fairly certain also used for fields, not widgets

/** * Implementation of hook_allowed_values(). */function biblioreference_allowed_values($field) {  $references = _nodereference_potential_references($field);  $options = array();  foreach ($references as $key => $value) {    // Views theming runs check_plain (htmlentities) on the values.    // We reverse that with html_entity_decode.    $options[$key] = html_entity_decode(strip_tags($value['rendered']), ENT_QUOTES);  }  return $options;}/** * Fetch an array of all candidate referenced nodes. * * A more specialized version of _nodereference_potential_references(). * * In our case we will NOT use this value for autocomplete results. * * SO: do we need this at all?  Customization ON HOLD until that is answered. * * This info is used in various places (aloowed values, autocomplete results, * input validation...). Some of them only need the nids, others nid + titles, * others yet nid + titles + rendered row (for display in widgets). * The array we return contains all the potentially needed information, and lets * consumers use the parts they actually need. * * @param $field *   The field description. * @param $string *   Optional string to filter titles on (used by autocomplete). * @param $match *   Operator to match filtered name against, can be any of: *   'contains', 'equals', 'starts_with' * @param $ids *   Optional node ids to lookup (the $string and $match arguments will be *   ignored). * @param $limit *   If non-zero, limit the size of the result set. * * @return *   An array of valid nodes in the form: *   array( *     nid => array( *       'title' => The node title, *       'rendered' => The text to display in widgets (can be HTML) *     ), *     ... *   ) */function _biblioreference_potential_references($field, $string = '', $match = 'contains', $ids = array(), $limit = NULL) {  static $results = array();  // Create unique id for static cache.  $cid = $field['field_name'] .':'. $match .':'. ($string !== '' ? $string : implode('-', $ids)) .':'. $limit;  if (!isset($results[$cid])) {    $related_types = array();    $where = array();    $args = array();    if (is_array($field['referenceable_types'])) {      foreach (array_filter($field['referenceable_types']) as $related_type) {        $related_types[] = "n.type = '%s'";        $args[] = $related_type;      }    }      $where[] = implode(' OR ', $related_types);      if (!count($related_types)) {      return array();    }      if ($string !== '') {      $match_operators = array(        'contains' => "LIKE '%%%s%%'",        'equals' => "= '%s'",        'starts_with' => "LIKE '%s%%'",      );      $where[] = 'n.title '. (isset($match_operators[$match]) ? $match_operators[$match] : $match_operators['contains']);      $args[] = $string;    }    elseif ($ids) {      $where[] = 'n.nid IN (' . db_placeholders($ids) . ')';      $args = array_merge($args, $ids);    }      $where_clause = $where ? 'WHERE ('. implode(') AND (', $where) .')' : '';    $sql = db_rewrite_sql("SELECT n.nid, n.title AS node_title, n.type AS node_type FROM {node} n $where_clause ORDER BY n.title, n.type");    $result = $limit ? db_query_range($sql, $args, 0, $limit) : db_query($sql, $args);    $references = array();    while ($node = db_fetch_object($result)) {      $references[$node->nid] = array(        'title' => $node->node_title,        'rendered' => $node->node_title,      );    }    // Store the results.    $results[$cid] = $references;  }  return $results[$cid];}