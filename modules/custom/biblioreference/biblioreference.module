<?php
// $Id$ 

/**
 * @file biblioreference.module
 * [biblioreference] Add Biblio citation to a node (with special PubMed integration)
 * Originally called the add_citation module.  It replaces the
 * generic nodereference autocomplete widget with one specialized to use 
 * additional Bibliography module specific fields to find biblio nodes.
 * 
 * In addition to nodereference, we used noderefcreate.module (not in CVS)
 * as a module showing what must be taken to create a new nodereference widget.
 */

/**
 * Implementation of hook_menu().
 */
function biblioreference_menu() {
  $items = array();
  $items['biblioreference/autocomplete'] = array(
    'title' => 'Biblioreference autocomplete',
    'page callback' => 'biblioreference_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  
  // @TODO - this should probably be in a separate module
  $items['admin/settings/biblio/import_pubmed'] = array(
    'title' => t('Import Pubmed'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('biblioreference_pubmed_import_form'),
    'access arguments' => array('create biblio'),  // not using the somewhat silly biblio_access wrapper function
//    'file' => 'biblio.import.export.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 8,
  );

  // @TODO - other location for menu?  change access arg.  admin include?
  $items['admin/settings/biblio/biblioreference'] = array(
    'title' => t('Biblioreference settings'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('biblioreference_settings_form'),
    'file' => 'biblioreference.admin.inc',
    'access arguments' => array('administer biblio'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 7,
  );

  $items['biblioreference/add/citation'] = array(
    'title' => 'Add Citation',
    'page callback' => 'biblioreference_add_citation',
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('create biblio'),
    'file' => 'node.pages.inc',
    'file path' => drupal_get_path('module', 'node'),
  );
  
  return $items;
}


/**
 * Menu callback; Retrieve a pipe delimited string of autocomplete suggestions for existing users
 */
function biblioreference_autocomplete($field_name, $string = '') {
  $fields = content_fields();
  $field = $fields[$field_name];
  $match = isset($field['widget']['autocomplete_match']) ? $field['widget']['autocomplete_match'] : 'contains';
  $matches = array();

  $references = biblioreference_match_nodes($string, $match = 'starts_with', 10);
  foreach ($references as $id => $row) {
    // Add a class wrapper for a few required CSS overrides.
    $matches[$row['title'] ." [nid:$id]"] = '<div class="reference-autocomplete">'. $row['rendered'] . '</div>';
  }
  drupal_json($matches);
}


/**
 * Menu callback for biblioreference add citation.
 */
function biblioreference_add_citation() {
  $output = '';
  $output .= '<h2>' . t('Reference Source') . '</h2>';
  $output .= '<ul>';
  $output .= '<li><h3>';
  $output .= t('Import Citations from PubMed');
  $output .= '</h3>';
  $output .= drupal_get_form('biblioreference_pubmed_import_form');
  $output .= '</li>';
  $output .= '<li><h3>';
  $output .= t('<a href="@url">Create a Reference that is not in PubMed</a>', array('@url' => url('node/add/biblio')));
  $output .= '</h3>';
  
  // @TODO  - of no use here, the choose reference type refreshes and leaves
  // the user on the same page -- which works, but is a confusing UI
//  $output .= drupal_get_form('biblioreference_embed_node_form_reuse', 'biblio');
  
  return $output;
}

/**
 *
 */
function biblioreference_embed_node_form_reuse(&$form_state, $type = 'page') {
  global $user;

  $form = array();
  // Custom form top
  $form['biblioreference_top'] = array(
    '#type' => 'markup',
    '#title' => '<fieldset class=" collapsible">
    <legend>Create a Reference that is not in PubMed</legend>',
    '#default_value' => isset($form_state['values']['top_example']) ? $form_state['values']['top_example'] : '',
  );
  // Custom form bottom
  $form['biblioreference_bottom'] = array(
    '#type' => 'markup',
    '#title' => '</fieldset>',
    '#default_value' => isset($form_state['values']['bottom_example']) ? $form_state['values']['bottom_example'] : '',
    '#required' => TRUE,
  );
  
  if (node_access('create', $type)) {

    // Initialize new node:
    $node = array('uid' => $user->uid, 'name' => $user->name, 'type' => $type);

    $form += drupal_retrieve_form($type .'_node_form', $form_state, $node);
    drupal_prepare_form($type .'_node_form', $form, $form_state);
  }

  // Preserve the old #theme property.
  $form['#theme_saved'] = $form['#theme'];
  $form['#theme'] = 'embed_example_node_form_reuse';

  // Register an after build callback
// see https://more.zites.net/embed-a-node-form-with-drupal-6 
// if we want to add our own submit handler to the form - using for markup now
// which means it wasn't necessary to add it to the form in the first place
//  $form['#after_build'][] = 'embed_example_after_build';

  return $form;
}


/**
 * Implementation of hook_theme().
 */
function biblioreference_theme() {
  return array(
    'biblioreference_node_form_reuse' => array(
      'arguments' => array('elements' => NULL),
    ),
  );
}

/**
 * Themes the form to put the custom parts of the form to the top and the bottom.
 */
function theme_biblioreference_node_form_reuse($form) {
  $top = drupal_render($form['biblioreference_top']);
  $bottom = drupal_render($form['biblioreference_bottom']);

  if (isset($form['#theme_saved'])) {
    // Apply the theme of the embedded form
    $form['#theme'] = $form['#theme_saved'];
    unset($form['#theme_used']);
  }

  return $top . drupal_render($form) . $bottom;
}




/**
 * Match biblio nodes based on index of words from title.
 *
 * Used in autocomplete function.
 *
 * The index could be extended to include words from the abstract or a keywords
 * field.
 */
function biblioreference_match_nodes($string, $match = 'starts_with', $limit = 10) {
  $words = search_index_split($string);
  // the difference with these match operators is that they apply per word
  $match_operators = array(
    'contains' => "LIKE '%%%s%%'",
    'equals' => "= '%s'",
    'starts_with' => "LIKE '%s%%'",
  );
  
  $where[] = "n.type = 'biblio'";
  $where[] = 'btk.word ' . $match_operators[$match];
// for multiple words we're going to have to string a bunch of these together with "OR"
// for now we'll take only the first word as a proof of concept
  $args[] = $words[0];
  
  $where_clause = $where ? 'WHERE ('. implode(') AND (', $where) .')' : '';

// right way -- actually, no need for db_rewrite_sql 'cause we aren't honoring node access-- or are we?  I guess we have n.nid in there and that can be acted on
//    $sql = db_rewrite_sql("SELECT n.nid, n.title AS node_title, n.type AS node_type FROM {node} n $where_clause ORDER BY n.title, n.type");
//  $result = db_query( LIMIT %d", $limit);
  $sql = db_rewrite_sql("SELECT COUNT(btk.nid) as nidcount, btk.nid, n.title FROM {biblioreference_title_keyword} btk LEFT JOIN {node} n ON n.nid=btk.nid $where_clause GROUP BY nid ORDER BY nidcount DESC");
  $result = $limit ? db_query_range($sql, $args, 0, $limit) : db_query($sql, $args);
  
  $references = array();
$references[666] = array(
  'title' => 'Curses it does not really work.',
  'rendered' => $sql,
);
  while ($node = db_fetch_object($result)) {
    $references[$node->nid] = array(
      'title' => $node->node_title,
      'rendered' => $node->node_title,
    );
  }

  return $references;
}



function biblioreference_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['type'])) {
    $node = $form['#node'];
    if ($form['type']['#value'] .'_node_form' == $form_id) {  
      $fields = content_fields();
      foreach ($form as $key => $item) {
        if (is_array($item)) {
        //  firep($item['#type'], $key);
          $type = $item['#type'];
          if ($type == 'fieldset') { // loop through all the subitems.
            foreach ($form[$key] as $subkey => $subitem) {
              biblioreference_alter_item($form[$key], $subkey, $subitem, $fields);
            }
          }
          else {
            biblioreference_alter_item($form, $key, $item, $fields);
          }
        }
        
      }
    }
  }

  if (isset($form['type']) && $form['type']['#value'] .'_node_settings' == $form_id) {
// @debug
drupal_set_message('<pre>'.var_export($form,TRUE).'</pre>');

    $form['workflow']['upload_'. $form['type']['#value']] = array(
      '#type' => 'radios',
      '#title' => t('Attachments'),
      '#default_value' => variable_get('upload_'. $form['type']['#value'], 1),
      '#options' => array(t('Disabled'), t('Enabled')),
    );
  }
}

// @TODO - accept multiple pubmed IDs


////////////////////////////////////////////////////////////////////////////
// Indexing related functions (for faster, more comprehensive autocomplete)
////////////////////////////////////////////////////////////////////////////


/**
 * Implementation of hook_cron().
 *
 * If this module is enabled on a site with a large number of existing biblio
 * nodes, there is a chance the first cron run will fail.  If this proves to be
 * a problem, follow the practice of node_update_index().  Another option would
 * be to piggyback on hook_nodeapi's 'update index' op, and not do our own 
 * hook_cron implementation at all.
 */
function biblioreference_cron() {
  $cron_last = variable_get('cron_last', 0);  // returns timestamp
  $result = db_query("SELECT title, nid, changed FROM {node} WHERE type = 'biblio' AND changed >= $cron_last");
  while ($biblio = db_fetch_object($result)) {
// @debug
// drupal_set_message('in cron result: <pre>'.var_export($biblio,TRUE).'</pre>');

    $words = search_index_split($biblio->title);
    foreach ($words as $word) {
      // pity PostgreSQL doesn't have INSERT ... ON DUPLICATE KEY UPDATE
      // although we never want to update... only add if not already there
      if (!db_result(db_query("SELECT nid FROM {biblioreference_title_keyword} btk WHERE word = '%s' AND nid = %d", $word, $biblio->nid))) {
        db_query("INSERT INTO {biblioreference_title_keyword} (word, nid) VALUES ('%s', %d)", $word, $biblio-nid);
      }
    }
  }
}


/**
 * Implementation of hook_nodeapi().
 *
 * We never remove words from a biblio's index, even though it may be edited
 * to change the title.  This is a feature, not a bug  ;-)
 */
function biblioreference_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if ($node->type != 'biblio') {
    return;  // if it's not a biblio node, we're done with this
  }
  switch ($op) {
    case 'delete':
      db_query("DELETE FROM {biblioreference_keyword} WHERE nid = %d", $node->nid);
      break;
  }
}


/**
 * Clears the index of biblioreference nodes and sets re-indexing to start.
 */
function biblioreference_index_wipe() {
  db_query('DELETE FROM {biblioreference_keyword}');
  variable_set('biblioreference_cron_last', 0);
}


/**
 * Return a form used to import files into biblio.
 *
 * @return
 *   An array which will be used by the form builder to build the import form
 */
function biblioreference_pubmed_import_form() {
  global $user;
  $form['biblioreference_pubmed_id'] = array(
    '#type' => 'textfield',
    '#title' => t('PubMed ID'),
    '#description' => t('The PubMed ID of an article.'),
    '#required' => TRUE,
  );

  // this matches the check in biblio.import.export.inc's biblio_save_node().
  if (user_access('administer nodes')) {
    module_load_include('inc', 'biblio', 'biblio.import.export');
    if (function_exists('_biblio_admin_build_user_select')) {
    // redundant if statement; no need to risk a parse error for this gravy
      $form['userid'] = _biblio_admin_build_user_select($user->uid);
    }
  }
  // Get the vocabularies  attached to the biblio node type ...
  $vocabularies = module_invoke('taxonomy', 'get_vocabularies', 'biblio');
  // ... and print a form to select the terms in each of them
  $form['import_taxonomy'] = array (
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Taxonomy Settings'),
    '#description' => t('Typically you don\'t have to do anything here, however if you wish, you may select terms to be assigned to imported records, this effectively adds a key word to all entries being imported. By default, all incoming key words are added to the Biblio Keywords vcabulary, you may either relate incoming entires to an existing key word OR select a term(s) from another vocabulary to relate all incoming entires to.')
  );
  if (count($vocabularies)) {
    $i = 0;
    foreach ($vocabularies as $vocabulary) {
      $form['import_taxonomy']['vocabulary'. $i] = module_invoke('taxonomy', 'form', $vocabulary->vid, 0);
      $form['import_taxonomy']['vocabulary'. $i++]['#description'] = t("Select taxonomy term to assigned to imported entries");
    }
  } else {
    $vocab_msg = t('There are currently no vocabularies assigned to the biblio node type, please go the the !url page to change this', array ('!url' => l(t('admin/content/taxonomy'), 'admin/content/taxonomy')));
    $form['import_taxonomy']['vocabulary_message'] = array (
      '#value' => '<p><div>'. $vocab_msg .'</div></p>'
    );
  }
  $form['button'] = array ('#type' => 'submit', '#value' => t('Import from PubMed'));
  return $form;
}

/**
 * Implementation of hook_validate() for biblioreference_pubmed_import_form.
 */
function biblioreference_pubmed_import_form_validate($form, &$form_state) {
  // @TODO
}


/**
 * Implementation of hook_submit() for the biblio_import_form.
 */
function biblioreference_pubmed_import_form_submit($form, &$form_state) {
  $pmid = $form_state['values']['biblioreference_pubmed_id'];
  $uid = $form_state['values']['userid'];
  // @TODO - can you add vocabularies?  What happens to 'vocabulary0' then?
  $term_ids[] = $form_state['values']['vocabulary0'];

  $efetch_url = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=' . $pmid . '&retmode=xml';

// @debug
//  $efetch_load = simplexml_load_file($efetch_url);
// drupal_set_message('<pre>'.var_export($efetch_load,TRUE).'</pre>');

  $result = biblioreference_load_bibtext_by_pmid($pmid);
  $watchdog_level = (isset($result['watchdog_level'])) ? $result['watchdog_level'] : WATCHDOG_INFO;
  watchdog('biblioreference', $result['watchdog_status'], $watchdog_level);
  $article_bib = $result['article_bib'];
  
  $data = $result['article_bib'];

  $nids = biblioreference_bibtex_import($data);

  foreach ($nids as $node_id) {
    if (count($tid)) {
      module_invoke('taxonomy', 'node_save', $node_id, $term_ids);
    }
    db_query('UPDATE {node} SET uid = %d WHERE nid = %d', $uid, $node_id);
    db_query('UPDATE {node_revisions} SET uid = %d WHERE nid = %d', $uid, $node_id);
    
    // Not worth the db query to get the title, but here's the link.
    drupal_set_message(t('Imported <a href="@url">bibliographic citation</a>.', array('@url' => url('node/' . $node_id))));
  }

}


/**
 * Load a single bubtext by pubmed ID.
 *
 * Taken directly from gopubmed.module (our upgraded to D6 version), function
 * gopubmed_load_bibtext_by_pmid($primaryId, $db = 'pubmed').
 * 
 * @TODO: break into smaller functions, maybe move to another module
 * or best get changes incorporated into gopubmed and keep dependency.
 */
function biblioreference_load_bibtext_by_pmid($primaryId, $db = 'pubmed') {
  $results = array();
  $article_bib = '';
// @TODO - security here
      $sql_pmid = db_result(db_query("SELECT COUNT(*) from {biblio} WHERE `biblio_custom3` = '$primaryId'"));
      if ($sql_pmid == 0) {
        $results['watchdog_status'] = t("This is new primary ID: @pmid", array('@pmid' => $primaryId));
        // ESummary Retrieves document summaries from a list of primary IDs
        // which we got from the ESearch
        $esummary_url = "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=$db&id=$primaryId&retmode=xml";
        $esummary_load = simplexml_load_file($esummary_url);
        $summaryid = $esummary_load->DocSum[0]->Id;
      
        /***Now creating the pubmed.bib file***/
        $article_bib .= '@article{' . $summaryid . ',' . "\n";

        foreach ($esummary_load->DocSum[0]->Item as $summary) {
	        $authorlist="";
          $author_all="";
          if($summary['Name'] == "AuthorList") {
// @TODO I think this is what must change for proper author import            
            foreach ($summary->Item as $authorlist) {
              $author_all .=  $authorlist . ' , '. "\n";
            }
            $article_bib .= 'author = {' . $author_all . '},'. "\n";
          }
          else {
            if($summary['Name'] == "Author")
              $article_bib .= 'author = {' . $summary . '},'. "\n";
          }
          if($summary['Name'] == "Title")
            $title           = $summary;
          else if($summary['Name'] == "PubDate")
            $pubdate         = $summary;
          else if($summary['Name'] == "ePubDate")
            $epubdate        = $summary;
          else if($summary['Name'] == "Source")
            $journal         = $summary;
          else if($summary['Name'] == "Volume")
            $volume          = $summary;
          else if($summary['Name'] == "Pages")
            $pages	     = $summary;
          else if($summary['Name'] == "Issue")
            $issue           = $summary;
          else if($summary['Name'] == "Pagination")
            $pagination      = $summary;
          else if($summary['Name'] == "PmId")
            $pmid            = $summary;
          else if($summary['Name'] == "SortDate")
            $sortdate        = $summary;
          else if($summary['Name'] == "Links")
            $links           = $summary;
          else if($summary['Name'] == "PmcLiveDate")
            $pmclivedate     = $summary;
          else if($summary['Name'] == "Abstract")
            $Abstract        = $summary;
          else if($summary['Name'] == "XmlData")
            $xmldata         = $summary;
          else if($summary['Name'] == "FullJournalName")
            $fullJournalName = $summary;
        
          if($fullJournalName == "")
            $journalname = $journal;
          else
            $journalname = $fullJournalName;
        }
          
        /*
         * Now getting the full article link through ELink.
         * ELink Checks for the existence of an external or Related Articles link from a list of one or more primary
         * IDs.  Retrieves primary IDs and relevancy scores for links to Entrez databases or Related Articles;  creates
         * a hyperlink to the primary LinkOut provider for a specific ID and database, or lists LinkOut URLs and
         * Attributes for multiple IDs
         **/
        $llink_url = "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/elink.fcgi?dbfrom=pubmed&id=$primaryId&cmd=prlinks";
        $llink_load = simplexml_load_file($llink_url);
    if (!is_object($llink_load)) {
      drupal_set_message(t("Failed to fetch object from eutils.ncbi.nlm.nih.gov."), 'error');
// @debug
drupal_set_message('<pre>'.var_export($llink_load,TRUE).'</pre>');
      
      return;
    }
        
        $llink_array = $llink_load->ObjUrl->xpath("//Url");
        $article_link = $llink_array[0];
          
        // Creating pubmed url
        $custom1 = "http://www.ncbi.nlm.nih.gov/pubmed/$primaryId?dopt=Abstract";
        
        // Getting abstract through EFetch.
        // Retrieves records in the requested format from a list of one or 
        // more primary IDs or from the user's environment.
        $efetch = "http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=$primaryId&retmode=xml";
        $efetch_load = simplexml_load_file($efetch);
        if (!is_object($efetch_load)) {
          drupal_set_message(t("Failed to fetch object from <em>@url</em>.", array('@url' => $efetch)), 'error');      
          return;
        }
      
        $abstract = $efetch_load->Abstract->xpath("//AbstractText");
        $final_abstract = $abstract[0];
        
        $title = str_replace("{"," ",$title);
        $title = str_replace("}"," ",$title);
        
        $article_bib .= 'title = {' . $title  . '},'. "\n";
        $article_bib .= 'year = {' . $pubdate . '},'. "\n";
        $article_bib .= 'journal = {' . $journalname . '},'. "\n";
        $article_bib .= 'volume = {' . $volume . '},'. "\n";
        if($number !=''){$article_bib .= 'number = {' . $number . '},'. "\n";}
        $article_bib .= 'pages={' . $pages . '},'. "\n";
        if($note !=''){$article_bib .= 'note = {' . $note . ' Additional Keywords: ' . $keywordlist . '},'. "\n";}
        $article_bib .= 'keywords = {' . $keywords . '},'. "\n";  
        $article_bib .= 'isbn={' . $isbn . '},'. "\n";
        $article_bib .= 'language = {' . $language . '},'. "\n";
        $article_bib .= 'abstract = {' . $final_abstract . '},'. "\n";
        $article_bib .= 'url = {' . $article_link . '},' . "\n";
        $article_bib .= 'custom1 = {' . $custom1 . '},' . "\n";
        $article_bib .= 'custom2 = {' . $search_term . '},' . "\n";
        $article_bib .= 'custom3 = {' . $primaryId . '}' . "\n";
        $article_bib .= '}';

        $results['article_bib'] = $article_bib;      
      }
      else {
        $results['watchdog_status'] = t("Publication not entered. PMID @pmid already there.", array('@pmid' => $primaryId));
      }

  return $results;
}


/**
 * Import bibtex data.
 *
 * @param $data
 *   the contents of a bibtex file passed as one big string
 * @param $node
 *   an array (populated in biblio_import() ), containing the boiler plate
 *   information common to all nodes
 * @return
 *   an array of node ids
 */
function biblioreference_bibtex_import($data, $batch = NULL, $session_id = NULL) {
  $nids = array();
  module_load_include('php', 'biblio', 'bibtexParse/PARSEENTRIES');
  $bibtex = new PARSEENTRIES();  
  $bibtex->loadBibtexString($data);
  
//  $bibtex->openBib($file->filepath);
  $bibtex->extractEntries();
  if ($bibtex->count) {
    $nids = $bibtex->bib2node($batch, $session_id);
  }
  return $nids;

}


/**
 * Implementation of hook_alter_item().
 */
function biblioreference_alter_item(&$form, $key, $item, $fields) {  
  $field_name = strstr($key, 'field_');
  if (isset($fields[$field_name]) && $fields[$field_name]['type'] == 'nodereference') {
    $type = $form['type']['#value'];
    $field = content_fields($field_name, $form['type']['#value']);
    
    if ($field['widget']['type'] == 'nodereference_autocomplete') {
      $suffix = '<div>';
      $suffix .= t('* If your reference is not in PD Biblio, <a href="@url" target="_BLANK">add a new citation in PDBiblio</a> manually.  This link will take you to a new window. After creating the reference, please remember to add it to the article.', array('@url' => url('biblioreference/add/citation')));
      $suffix .= '</div>';
      $form[$key]['#suffix'] = $suffix;
    }
    
  }
}


/**
 * Implementation of hook_theme_registry_alter().
 */
function biblioreference_theme_registry_alter($theme_registry) {
  if (!empty($theme_registry['biblio_tagged_link'])) {
    $theme_registry['biblio_tagged_link']['function'] = 'biblioreference_theme_biblio_tagged_link';
  }  
}

/** 
 * Creates a link to export a node (or view) in EndNote Tagged format.
 *
 * Overrides biblio/biblio_theme.inc's theme_biblio_tagged_link().
 * 
 * @param $base this is the base url (defaults to /biblio)
 * @param $nid  the node id, if NULL then the current view is exported
 * @return  a link (<a href=...>Endnote</a>)
 */
function biblioreference_theme_biblio_tagged_link($base, $nid = NULL) {
  if (module_exists('popups') && !empty($nid)) {
    $output .= l(t("Endnote"), "$base/export/tagged/$nid/popup", array('attributes'=>array('class' => 'popups', 'title' => t("Click to get the EndNote Tagged output "))));
  } else {
    $output .= l(t("Endnote"), "$base/export/tagged/$nid", array('attributes'=>array('title' => t("Click to download the EndNote Tagged formated file"))));
  }
  return $output;
}

/**
 * Apply a bibliographic style to the node
 *
 *
 * @param $node
 *   An object containing the node data to render
 * @param $base
 *   The base URL of the biblio module (defaults to /biblio)
 * @param $inline
 *   A logical value indicating if this is being rendered within the
 *   Drupal framwork (false) or we are just passing back the html (true)
 * @return
 *   The styled biblio entry
 */
function biblioreference_style_biblio($node, $base = 'biblio', $inline = false) {
  $contrib_array = _biblioreference_format_authors($node->biblio_contributors, $inline);
  $authors = $contrib_array[1];
  $output .= '<span class="biblio-authors">' . $authors . "</span>.&nbsp; \n";
  switch ($node->biblio_type) {

    default :
      if (isset ($node->biblio_year)) {
        $output .= check_plain($node->biblio_year) . ".&nbsp;&nbsp;";
      }
      $output .= '<span class="biblio-title">';
      $output .= $inline ? l("$node->title", "$base/viewinline/$node->nid") : l("$node->title", "node/$node->nid");
      $output .= ". </span> \n";
      $output .= (!empty ($node->biblio_secondary_title)) ? check_plain($node->biblio_secondary_title) . '. ' : '';
      $output .= (!empty ($node->biblio_volume)) ? check_plain($node->biblio_volume) : '';
      $output .= (!empty ($node->biblio_issue)) ? '(' . check_plain($node->biblio_issue) . ')' : '';
      $output .= (!empty ($node->biblio_pages)) ? ':' . str_replace(" ", "", check_plain($node->biblio_pages)) . '.' : '';
      break; // generic
  }
  /*  if ($node->biblio_date) $output .= ', '. check_plain($node->biblio_date);
    if ($node->biblio_number) $output .= ', Number '. check_plain($node->biblio_number);
  
    if ($node->biblio_place_published) $output .= ', '. check_plain($node->biblio_place_published);
  */
  return $output;
}
function _biblioreference_format_authors($contributors, $inline = FALSE) {
  if (count($contributors)) {
    foreach ($contributors as $key => $author) {
      $format = $author['prefix'] . ' ' . $author['lastname'] . ' ';
      $format .= !empty ($author['firstname']) ? ' ' . drupal_substr($author['firstname'], 0, 1) : '';
      $format .= !empty ($author['initials']) ? str_replace(' ', '', $author['initials']) : '';
      if (variable_get('biblio_author_links', 1)) {
        $base = variable_get('biblio_base', 'biblio');
        $format = _biblio_author_link($format, $author['cid'], $base, $inline);
      }
      $author_array[$author['auth_catagory']] .= (!empty ($author_array[$author['auth_catagory']])) ? ', ' . $format : $format;
    }
  }
  if (count($author_array)) {
    return $author_array;
  } else {
    return array (
      1 => t('No author information available')
    );
  }
}

/**
 * Pubmed style formatter.  See biblioreference_cck.module
 */


