<?php
// $Id$ 

/**
 * @file biblioreference.module
 * [biblioreference] Add Biblio citation to a node (with special PubMed integration)
 * Originally called the add_citation module.  It replaces the
 * generic nodereference autocomplete widget with one specialized to use 
 * additional Bibliography module specific fields to find biblio nodes.
 * 
 * In addition to nodereference, we used noderefcreate.module (not in CVS)
 * as a module showing what must be taken to create a new nodereference widget.
 */

// functions in this include will move to gopubmed.module when Zaloni commits
require_once('pubmed_import.inc');

/**
 * Implementation of hook_menu().
 */
function biblioreference_menu() {
  $items = array();
  $items['biblioreference/autocomplete'] = array(
    'title' => 'Biblioreference autocomplete',
    'page callback' => 'biblioreference_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  
  // @TODO - this should probably be in a separate module
  $items['admin/settings/biblio/import_pubmed'] = array(
    'title' => t('Import Pubmed'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('biblioreference_pubmed_import_form'),
    'access arguments' => array('create biblio'),  // not using the somewhat silly biblio_access wrapper function
    'file' => 'pubmed_import.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 8,
  );

  // @TODO - other location for menu?  change access arg.  admin include?
  $items['admin/settings/biblio/biblioreference'] = array(
    'title' => t('Biblioreference settings'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('biblioreference_settings_form'),
    'file' => 'biblioreference.admin.inc',
    'access arguments' => array('administer biblio'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 7,
  );

  $items['biblioreference/add/citation'] = array(
    'title' => 'Add Citation',
    'page callback' => 'biblioreference_add_citation',
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('create biblio'),
    'file' => 'node.pages.inc',
    'file path' => drupal_get_path('module', 'node'),
  );
  
  return $items;
}


/**
 * Menu callback; Retrieve a pipe delimited string of autocomplete suggestions for existing users
 */
function biblioreference_autocomplete($field_name, $string = '') {
//  $fields = content_fields();
//  $field = $fields[$field_name];
//  $match = isset($field['widget']['autocomplete_match']) ? $field['widget']['autocomplete_match'] : 'contains';
  $matches = array();

  $references = biblioreference_match_nodes($string, $match = 'starts_with', 10);
  foreach ($references as $id => $row) {
    // Add a class wrapper for a few required CSS overrides.
    $matches[$row['title'] ." [nid:$id]"] = '<div class="reference-autocomplete">'. $row['rendered'] . '</div>';
  }
  drupal_json($matches);
}


/**
 * Menu callback for biblioreference add citation.
 */
function biblioreference_add_citation() {
  $output = '';
  $output .= '<h2>' . t('Reference Source') . '</h2>';
  $output .= '<ul>';
  $output .= '<li><h3>';
  $output .= t('Import Citations from PubMed');
  $output .= '</h3>';
  $output .= drupal_get_form('biblioreference_pubmed_import_form');
  $output .= '</li>';
  $output .= '<li><h3>';
  $output .= t('<a href="@url">Create a Reference that is not in PubMed</a>', array('@url' => url('node/add/biblio')));
  $output .= '</h3>';
  
  // @TODO  - of no use here, the choose reference type refreshes and leaves
  // the user on the same page -- which works, but is a confusing UI
//  $output .= drupal_get_form('biblioreference_embed_node_form_reuse', 'biblio');
  
  return $output;
}

/**
 *
 */
function biblioreference_embed_node_form_reuse(&$form_state, $type = 'page') {
  global $user;

  $form = array();
  // Custom form top
  $form['biblioreference_top'] = array(
    '#type' => 'markup',
    '#title' => '<fieldset class=" collapsible">
    <legend>Create a Reference that is not in PubMed</legend>',
    '#default_value' => isset($form_state['values']['top_example']) ? $form_state['values']['top_example'] : '',
  );
  // Custom form bottom
  $form['biblioreference_bottom'] = array(
    '#type' => 'markup',
    '#title' => '</fieldset>',
    '#default_value' => isset($form_state['values']['bottom_example']) ? $form_state['values']['bottom_example'] : '',
    '#required' => TRUE,
  );
  
  if (node_access('create', $type)) {

    // Initialize new node:
    $node = array('uid' => $user->uid, 'name' => $user->name, 'type' => $type);

    $form += drupal_retrieve_form($type .'_node_form', $form_state, $node);
    drupal_prepare_form($type .'_node_form', $form, $form_state);
  }

  // Preserve the old #theme property.
  $form['#theme_saved'] = $form['#theme'];
  $form['#theme'] = 'embed_example_node_form_reuse';

  // Register an after build callback
// see https://more.zites.net/embed-a-node-form-with-drupal-6 
// if we want to add our own submit handler to the form - using for markup now
// which means it wasn't necessary to add it to the form in the first place
//  $form['#after_build'][] = 'embed_example_after_build';

  return $form;
}


/**
 * Implementation of hook_theme().
 */
function biblioreference_theme() {
  return array(
    'biblioreference_node_form_reuse' => array(
      'arguments' => array('elements' => NULL),
    ),
  );
}

/**
 * Themes the form to put the custom parts of the form to the top and the bottom.
 */
function theme_biblioreference_node_form_reuse($form) {
  $top = drupal_render($form['biblioreference_top']);
  $bottom = drupal_render($form['biblioreference_bottom']);

  if (isset($form['#theme_saved'])) {
    // Apply the theme of the embedded form
    $form['#theme'] = $form['#theme_saved'];
    unset($form['#theme_used']);
  }

  return $top . drupal_render($form) . $bottom;
}




/**
 * Match biblio nodes based on index of words from title.
 *
 * Used in autocomplete function.
 *
 * The index could be extended to include words from the abstract or a keywords
 * field.
 */
function biblioreference_match_nodes($string, $match = 'starts_with', $limit = 10) {
  $words = search_index_split($string);
  // the difference with these match operators is that they apply per word
  $match_operators = array(
    'contains' => "LIKE '%%%s%%'",
    'equals' => "= '%s'",
    'starts_with' => "LIKE '%s%%'",
  );
  
  $where_clause = "WHERE n.type = 'biblio'";

  $count = count($words);
  if ($count) {
    $where_clause .= ' AND ';
  }
  for ($i = 0; $i < $count; $i++) {
    $where[] = 'bk.word ' . $match_operators[$match];
  }
  $args = $words;
  $where_clause .= $where ? ' ('. implode(' OR ', $where) . ')' : '';

// @todo: put back in db_rewrite_sql if it won't break anything
// @TODO optimization: we may want to put title, authors, and journal title
// into a separate table so that we can do it without joins-- especially if
// the same table can be reused for theming purposes. 
$sql = "SELECT COUNT(bk.nid) AS matchcount, bk.nid AS nid, n.title AS node_title FROM {biblioreference_keyword} bk LEFT JOIN {node} n ON n.nid=bk.nid " . $where_clause . " GROUP BY nid ORDER BY matchcount DESC";
//  $sql = "SELECT bk.nid as nid, n.title as node_title from {biblioreference_keyword} bk left join {node} n on n.nid=bk.nid " . $where_clause;
  $result = $limit ? db_query_range($sql, $args, 0, $limit) : db_query($sql, $args);

  $references = array();

// $debug = 'Words: ' . implode($words, ', ') . ' and SQL: ' . $sql;
// $references[666] = array(
//  'title' => $debug,
//  'rendered' => $debug,
// );

  while ($node = db_fetch_object($result)) {
    $references[$node->nid] = array(
      'title' => $node->node_title . ' (' . $node->matchcount . ')',
      'rendered' => $node->node_title . ' (' . $node->matchcount . ') ' . ' <span>' . $node->nid . '</span>',
    );
  }

  return $references;

//@TODO delete junk below
  $where[] = 'btk.word ' . $match_operators[$match];
// for multiple words we're going to have to string a bunch of these together with "OR"
// for now we'll take only the first word as a proof of concept
  $args[] = $words[0];
  
  $where_clause = $where ? 'WHERE ('. implode(') AND (', $where) .')' : '';

// right way -- actually, no need for db_rewrite_sql 'cause we aren't honoring node access-- or are we?  I guess we have n.nid in there and that can be acted on
//    $sql = db_rewrite_sql("SELECT n.nid, n.title AS node_title, n.type AS node_type FROM {node} n $where_clause ORDER BY n.title, n.type");
//  $result = db_query( LIMIT %d", $limit);
  $sql = db_rewrite_sql("SELECT COUNT(btk.nid) as nidcount, btk.nid, n.title FROM {biblioreference_title_keyword} btk LEFT JOIN {node} n ON n.nid=btk.nid $where_clause GROUP BY nid ORDER BY nidcount DESC");
  $result = $limit ? db_query_range($sql, $args, 0, $limit) : db_query($sql, $args);
  
  $references = array();
$references[666] = array(
  'title' => 'Curses it does not really work.',
  'rendered' => $sql,
);
  while ($node = db_fetch_object($result)) {
    $references[$node->nid] = array(
      'title' => $node->node_title,
      'rendered' => $node->node_title,
    );
  }

  return $references;
}

/**
 * Implementation of hook_form_alter().
 */
function biblioreference_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['type'])) {
    $node = $form['#node'];
    if ($form['type']['#value'] .'_node_form' == $form_id) {  
      $fields = content_fields();
      foreach ($form as $key => $item) {
        if (is_array($item)) {
        //  firep($item['#type'], $key);
          $type = $item['#type'];
          if ($type == 'fieldset') { // loop through all the subitems.
            foreach ($form[$key] as $subkey => $subitem) {
              biblioreference_alter_item($form[$key], $subkey, $subitem, $fields);
            }
          }
          else {
            biblioreference_alter_item($form, $key, $item, $fields);
          }
        }
        
      }
    }
  }

  if (isset($form['type']) && $form['type']['#value'] .'_node_settings' == $form_id) {
// @TODO figure out what's going on here 
// @debug
// drupal_set_message('<pre>'.var_export($form,TRUE).'</pre>');
/*
    $form['workflow']['upload_'. $form['type']['#value']] = array(
      '#type' => 'radios',
      '#title' => t('Attachments'),
      '#default_value' => variable_get('upload_'. $form['type']['#value'], 1),
      '#options' => array(t('Disabled'), t('Enabled')),
    );
*/
  }
}

////////////////////////////////////////////////////////////////////////////
// Indexing related functions (for faster, more comprehensive autocomplete)
////////////////////////////////////////////////////////////////////////////

/**
 * Implementation of hook_cron().
 *
 * If this module is enabled on a site with a large number of existing biblio
 * nodes, there is a chance the first cron run will fail.  If this proves to be
 * a problem, follow the practice of node_update_index().  Another option would
 * be to piggyback on hook_nodeapi's 'update index' op, and not do our own 
 * hook_cron implementation at all.
 *
 * @TODO: optimize this function for fewer SQL queries
 * @TODO: move to biblioreference_widget or helper biblioreference_index module
 */
function biblioreference_cron() {
  $cron_last = variable_get('biblioreference_cron_last', 0);  // returns timestamp
drupal_set_message('cron_last: '.$cron_last);  //@debug
  $result = db_query("SELECT title, nid, vid, changed FROM {node} WHERE type = 'biblio' AND changed >= $cron_last");
  // expanded with-authors version below, above for testing only at this point
  while ($biblio = db_fetch_object($result)) {
// @debug
 drupal_set_message('in cron result: <pre>'.var_export($biblio,TRUE).'</pre>');
   // we are already getting this information anyway, putting this in while is
   // easier than redoing the SQL

    // note that search_index_split also calls search_simplify
    $title_words = search_index_split($biblio->title);
    $name_words = biblioreference_index_split_bulk(biblioreference_get_contributor_names($biblio));
    $journal_words = biblioreference_index_split_bulk(biblioreference_get_journal($biblio));
    $words = array_unique(array_merge($title_words, $name_words, $journal_words));
// @debug
 drupal_set_message('journal: <pre>'.var_export($journal_words,TRUE).'</pre>');
// @debug
 drupal_set_message('words: <pre>'.var_export($words,TRUE).'</pre>');
    foreach ($words as $word) {
      // @TODO consider re-using variable_get('minimum_word_size', 3);
      // to skip short words.  For now we just skip blank ones.
      if ($word) {
        // Search.module doesn't check if word exists for node before it inserts
        // if (!db_result(db_query("SELECT nid FROM {biblioreference_keyword} btk WHERE word = '%s' AND nid = %d", $word, $biblio->nid))) {
        // we'll simply suppress failures also
        @db_query("INSERT INTO {biblioreference_keyword} (word, nid) VALUES ('%s', %d)", $word, $biblio->nid);
      }
    }
  }
}

/**
 * Fetch the names of all contributors on a bibliography.
 *
 * @param $biblio
 *  An object containing the nid and vid of the bibliography node for which
 * author names are sought.
 *
 * @return
 *  An array of contributor full names.
 */
function biblioreference_get_contributor_names($biblio) {
  $contributor_names = array();
  $result = db_query("SELECT d.name FROM {biblio_contributor_data} d LEFT JOIN {biblio_contributor} c ON d.cid = c.cid WHERE c.nid = %d and c.vid = %d", array($biblio->nid, $biblio->vid));
  while ($contributor = db_fetch_array($result)) {
    $contributor_names[] = $contributor['name'];
  }
  return $contributor_names;
}

/**
 * Return the journal title and year associated with a Biblio node.
 *
 * This function could easily be rewritten/rebranded as 'biblio_get_values' 
 *
 * @param $biblio
 *  An object containing at least the nid of a biblio node.
 * @return
 *  An array matching the values passed in.
 */
function biblioreference_get_journal($biblio, $fields = array('biblio_secondary_title', 'biblio_year')) {
  $values = array();
  $num_fields = count($fields);
  $columns = '';
  for ($i = 0; $i < $num_fields; $i++) {
    if ($i > 0) {
      $columns .= ', ';
    }
    $columns .= '%s';
  }
  $query = 'SELECT ' . $columns . ' FROM {biblio} WHERE vid = %d';
  $sql_args = $fields;
  $sql_args[] = $biblio->vid;
  $values = db_fetch_array(db_query($query, $sql_args));
  return $values;
}

/**
 * Split an array of strings into an array of words.
 * 
 * Use search_index_split to take an array of strings and return an array of
 * all single words present.
 */
function biblioreference_index_split_bulk($strings) {
  $words = array();
  foreach ($strings as $string) {
    $words = array_merge($words, search_index_split($string));
  }
  return $words;
}

/**
 * Return array of single words from the contributor fields of biblio content.
 *
 * This is just a stripped down version of biblio_load_contributors, used as a
 * helper module for our implementation of hook_cron which creates an index of
 * keywords from the titles and authors of biblio nodes.
 *
  // we could get d.lastname, d.firstname in the query above, but if we
  // are going to split on spaces just in case there are multiple firstnames
  // or lastnames, we can just grab and split the single combined name field.
 * This could probably be done more efficiently as part of the main query,
 * using concat or something to make the authors one big field, but this is
 * cleaner.  @REVIEW
 *
 * @param vid
 *   The revision ID of a biblio node.
 * @return
 *   An array of keywords from the contributors (authors) to a biblio node.
 */
//  $query = 'SELECT bcd.name FROM {biblio_contributor} bc, {biblio_contributor_data} bcd WHERE bc.vid = %d AND bc.cid = bcd.cid;';


/**
 * Implementation of hook_nodeapi().
 *
 * We never remove words from a biblio's index, even though it may be edited
 * to change the title.  This is a feature, not a bug  ;-)
 */
function biblioreference_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if ($node->type != 'biblio') {
    return;  // if it's not a biblio node, we're done with this
  }
  switch ($op) {
    case 'delete':
      db_query("DELETE FROM {biblioreference_keyword} WHERE nid = %d", $node->nid);
      break;
  }
}

/**
 * Clears the index of biblioreference nodes and sets re-indexing to start.
 */
function biblioreference_index_wipe() {
  db_query('DELETE FROM {biblioreference_keyword}');
  variable_set('biblioreference_cron_last', 0);
}

/**
 * Implementation of hook_alter_item().
 */
function biblioreference_alter_item(&$form, $key, $item, $fields) {  
  $field_name = strstr($key, 'field_');
  if (isset($fields[$field_name]) && $fields[$field_name]['type'] == 'nodereference') {
    $type = $form['type']['#value'];
    $field = content_fields($field_name, $form['type']['#value']);
    
    if ($field['widget']['type'] == 'nodereference_autocomplete') {
      $suffix = '<div>';
      $suffix .= t('* If your reference is not in PD Biblio, <a href="@url" target="_BLANK">add a new citation in PDBiblio</a> manually.  This link will take you to a new window. After creating the reference, please remember to add it to the article.', array('@url' => url('biblioreference/add/citation')));
      $suffix .= '</div>';
      $form[$key]['#suffix'] = $suffix;
    }
    
  }
}

/**
 * Implementation of hook_theme_registry_alter().
 */
function biblioreference_theme_registry_alter($theme_registry) {
  if (!empty($theme_registry['biblio_tagged_link'])) {
    $theme_registry['biblio_tagged_link']['function'] = 'biblioreference_theme_biblio_tagged_link';
  }  
}

/** 
 * Creates a link to export a node (or view) in EndNote Tagged format.
 *
 * Overrides biblio/biblio_theme.inc's theme_biblio_tagged_link().
 * 
 * @param $base this is the base url (defaults to /biblio)
 * @param $nid  the node id, if NULL then the current view is exported
 * @return  a link (<a href=...>Endnote</a>)
 */
function biblioreference_theme_biblio_tagged_link($base, $nid = NULL) {
  if (module_exists('popups') && !empty($nid)) {
    $output .= l(t("Endnote"), "$base/export/tagged/$nid/popup", array('attributes'=>array('class' => 'popups', 'title' => t("Click to get the EndNote Tagged output "))));
  } else {
    $output .= l(t("Endnote"), "$base/export/tagged/$nid", array('attributes'=>array('title' => t("Click to download the EndNote Tagged formated file"))));
  }
  return $output;
}

/**
 * Apply a bibliographic style to the node
 *
 *
 * @param $node
 *   An object containing the node data to render
 * @param $base
 *   The base URL of the biblio module (defaults to /biblio)
 * @param $inline
 *   A logical value indicating if this is being rendered within the
 *   Drupal framwork (false) or we are just passing back the html (true)
 * @return
 *   The styled biblio entry
 */
function biblioreference_style_biblio($node, $base = 'biblio', $inline = false) {
  $contrib_array = _biblioreference_format_authors($node->biblio_contributors, $inline);
  $authors = $contrib_array[1];
  $output .= '<span class="biblio-authors">' . $authors . "</span>.&nbsp; \n";
  switch ($node->biblio_type) {

    default :
      if (isset ($node->biblio_year)) {
        $output .= check_plain($node->biblio_year) . ".&nbsp;&nbsp;";
      }
      $output .= '<span class="biblio-title">';
      $output .= $inline ? l("$node->title", "$base/viewinline/$node->nid") : l("$node->title", "node/$node->nid");
      $output .= ". </span> \n";
      $output .= (!empty ($node->biblio_secondary_title)) ? check_plain($node->biblio_secondary_title) . '. ' : '';
      $output .= (!empty ($node->biblio_volume)) ? check_plain($node->biblio_volume) : '';
      $output .= (!empty ($node->biblio_issue)) ? '(' . check_plain($node->biblio_issue) . ')' : '';
      $output .= (!empty ($node->biblio_pages)) ? ':' . str_replace(" ", "", check_plain($node->biblio_pages)) . '.' : '';
      break; // generic
  }
  /*  if ($node->biblio_date) $output .= ', '. check_plain($node->biblio_date);
    if ($node->biblio_number) $output .= ', Number '. check_plain($node->biblio_number);
  
    if ($node->biblio_place_published) $output .= ', '. check_plain($node->biblio_place_published);
  */
  return $output;
}

function _biblioreference_format_authors($contributors, $inline = FALSE) {
  if (count($contributors)) {
    foreach ($contributors as $key => $author) {
      $format = $author['prefix'] . ' ' . $author['lastname'] . ' ';
      $format .= !empty ($author['firstname']) ? ' ' . drupal_substr($author['firstname'], 0, 1) : '';
      $format .= !empty ($author['initials']) ? str_replace(' ', '', $author['initials']) : '';
      if (variable_get('biblio_author_links', 1)) {
        $base = variable_get('biblio_base', 'biblio');
        $format = _biblio_author_link($format, $author['cid'], $base, $inline);
      }
      $author_array[$author['auth_catagory']] .= (!empty ($author_array[$author['auth_catagory']])) ? ', ' . $format : $format;
    }
  }
  if (count($author_array)) {
    return $author_array;
  } else {
    return array (
      1 => t('No author information available')
    );
  }
}

/**
 * Pubmed style formatter.  See biblioreference_cck.module
 */


